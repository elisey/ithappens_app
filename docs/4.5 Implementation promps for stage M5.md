# Серия промптов для фазы M5: Состояние

## Контекст для всех промптов фазы M5

Приложение "ithappens" имеет полностью функциональный UI с навигацией, темами и модальными окнами. Теперь нужно реализовать сохранение состояния между сессиями: запоминание последней прочитанной истории и восстановление при следующем запуске. Это критично для удобства пользователей, которые читают истории в несколько подходов.

---

## Промпт M5.1: Сервис управления состоянием

````text
Создай сервис для сохранения и восстановления состояния приложения.

КОНТЕКСТ:
- Приложение должно запоминать последнюю прочитанную историю
- При перезапуске должна открываться та же история
- Использовать localStorage для персистентности
- Нужна обработка edge cases (недоступный localStorage, невалидные данные)

ЗАДАЧА:
1. Создай storageService с методами сохранения/загрузки
2. Добавь типобезопасность и валидацию
3. Реализуй fallback стратегии

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `src/services/storageService.ts`:
```typescript
interface StorageData {
  lastStoryId: number
  timestamp: number
  version: string
}

interface StorageOptions {
  prefix?: string // префикс для ключей
  version?: string // версия схемы данных
  ttl?: number // time to live в ms
}

class StorageService {
  private readonly prefix: string
  private readonly version: string
  private readonly ttl: number | null

  constructor(options?: StorageOptions)

  // Основные методы
  async getLastStoryId(): Promise<number | null>
  async setLastStoryId(id: number): Promise<boolean>

  // Дополнительные методы
  async clear(): Promise<void>
  async isAvailable(): Promise<boolean>
  async getStorageInfo(): Promise<StorageInfo>

  // Методы для других данных (расширяемость)
  async get<T>(key: string): Promise<T | null>
  async set<T>(key: string, value: T): Promise<boolean>
  async remove(key: string): Promise<boolean>
}

interface StorageInfo {
  available: boolean
  used: number // bytes
  quota: number // bytes
  items: number
}

// Дополнительные функции
function isStorageAvailable(): boolean
function migrate(oldData: unknown): StorageData | null
````

2. `src/services/storageService.test.ts`:

```typescript
describe('StorageService', () => {
  // Мокаем localStorage для тестов
  beforeEach(() => {
    // Setup mock localStorage
  })

  // Базовая функциональность
  test('saves and retrieves last story ID')
  test('returns null when no data exists')
  test('handles invalid stored data')

  // Версионирование
  test('migrates old data format')
  test('ignores incompatible versions')

  // TTL
  test('returns null for expired data')
  test('updates timestamp on save')

  // Edge cases
  test('handles localStorage unavailable')
  test('handles quota exceeded')
  test('handles corrupted JSON')
  test('handles concurrent access')

  // Очистка
  test('clears all stored data')
  test('removes specific keys')
})
```

3. `src/utils/storage.ts`:

```typescript
// Низкоуровневые утилиты для работы с localStorage

// Безопасное чтение из localStorage
function safeGetItem(key: string): string | null {
  try {
    return localStorage.getItem(key)
  } catch (error) {
    console.warn('Failed to read from localStorage:', error)
    return null
  }
}

// Безопасная запись в localStorage
function safeSetItem(key: string, value: string): boolean {
  try {
    localStorage.setItem(key, value)
    return true
  } catch (error) {
    console.warn('Failed to write to localStorage:', error)
    return false
  }
}

// Проверка доступности localStorage
function isLocalStorageAvailable(): boolean {
  try {
    const test = '__localStorage_test__'
    localStorage.setItem(test, test)
    localStorage.removeItem(test)
    return true
  } catch {
    return false
  }
}

// Подсчет использованного места
function getStorageSize(): number {
  let size = 0
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      size += localStorage[key].length + key.length
    }
  }
  return size * 2 // UTF-16
}

// Сжатие данных для экономии места (опционально)
function compress(data: string): string
function decompress(data: string): string
```

4. `src/hooks/usePersistedState.ts`:

```typescript
// Хук для персистентного состояния

interface UsePersistedStateOptions {
  key: string
  defaultValue?: any
  serialize?: (value: any) => string
  deserialize?: (value: string) => any
  ttl?: number
}

function usePersistedState<T>(
  options: UsePersistedStateOptions
): [T, (value: T | ((prev: T) => T)) => void, () => void] {
  // Синхронизация с localStorage
  // Обработка изменений в других вкладках
  // Дебаунс записи для производительности

  return [value, setValue, clear]
}

// Специализированная версия для story ID
function useLastStoryId(defaultId: number = 1): {
  lastStoryId: number
  setLastStoryId: (id: number) => void
  clearLastStoryId: () => void
}
```

5. `src/services/syncService.ts` (опционально):

```typescript
// Сервис синхронизации между вкладками

class SyncService {
  private channel: BroadcastChannel | null
  private listeners: Map<string, Set<Function>>

  // Инициализация канала связи
  init(channelName: string): void

  // Отправка изменений другим вкладкам
  broadcast(event: string, data: any): void

  // Подписка на изменения
  subscribe(event: string, callback: Function): () => void

  // Синхронизация состояния
  requestSync(): void

  // Очистка
  destroy(): void
}

// События синхронизации
interface SyncEvent {
  type: 'story-changed' | 'state-cleared' | 'sync-request'
  data: any
  timestamp: number
  tabId: string
}
```

КЛЮЧИ ХРАНИЛИЩА:

```
ithappens_last_story_id     - ID последней истории
ithappens_settings          - настройки пользователя (будущее)
ithappens_reading_progress  - прогресс чтения (будущее)
ithappens_favorites         - избранные истории (будущее)
ithappens_theme            - выбранная тема
```

ОБРАБОТКА ОШИБОК:

- localStorage недоступен (приватный режим)
- Превышена квота (обычно 5-10MB)
- Невалидный JSON в хранилище
- Устаревшие данные (другая версия схемы)
- Конкурентный доступ из разных вкладок

FALLBACK СТРАТЕГИИ:

1. Если localStorage недоступен - использовать sessionStorage
2. Если оба недоступны - хранить в памяти
3. При ошибке чтения - вернуть значение по умолчанию
4. При ошибке записи - логировать, но не прерывать работу

Выведи полную реализацию сервиса с тестами.

````

---

## Промпт M5.2: Интеграция состояния с приложением

```text
Интегрируй сервис состояния с основным приложением.

КОНТЕКСТ:
- StorageService реализован и протестирован
- Нужно подключить сохранение/восстановление к навигации
- При старте открывать последнюю историю или ID 1
- Сохранять текущую историю при каждом переходе

ЗАДАЧА:
1. Обнови App компонент для работы с состоянием
2. Добавь инициализацию при запуске
3. Реализуй автосохранение при навигации

ФАЙЛЫ ДЛЯ ОБНОВЛЕНИЯ:

1. `src/app.tsx` - интеграция состояния:
```typescript
import { StorageService } from './services/storageService'

function App() {
  const [currentStoryId, setCurrentStoryId] = useState<number | null>(null)
  const [isInitializing, setIsInitializing] = useState(true)
  const storageService = useRef(new StorageService())

  // Инициализация при запуске
  useEffect(() => {
    async function initialize() {
      try {
        // 1. Инициализировать StoryService
        await storyService.initialize(config.storiesUrl)

        // 2. Восстановить последнюю историю
        const lastId = await storageService.current.getLastStoryId()

        // 3. Проверить существование ID
        if (lastId && storyService.getById(lastId)) {
          setCurrentStoryId(lastId)
        } else {
          // Fallback на первую историю
          setCurrentStoryId(storyService.getFirstId())
        }
      } catch (error) {
        console.error('Failed to initialize:', error)
        // Показать error state
      } finally {
        setIsInitializing(false)
      }
    }

    initialize()
  }, [])

  // Сохранение при изменении истории
  useEffect(() => {
    if (currentStoryId !== null && !isInitializing) {
      storageService.current.setLastStoryId(currentStoryId)
        .catch(error => {
          console.warn('Failed to save state:', error)
          // Опционально: показать toast
        })
    }
  }, [currentStoryId, isInitializing])

  // Обработчики навигации с сохранением
  const handleNext = useCallback(() => {
    // Навигация + автосохранение через useEffect
  }, [])

  // ...остальная логика
}
````

2. `src/hooks/useAppState.ts` - централизованное управление:

```typescript
interface AppState {
  currentStoryId: number | null
  isLoading: boolean
  error: Error | null
  // Будущие поля
  readHistory?: number[]
  favorites?: Set<number>
  settings?: UserSettings
}

interface UseAppStateResult {
  state: AppState
  actions: {
    navigateNext: () => void
    navigatePrev: () => void
    navigateToId: (id: number) => void
    navigateToFirst: () => void
    navigateToLast: () => void
    resetState: () => void
  }
  storage: {
    save: () => Promise<void>
    restore: () => Promise<void>
    clear: () => Promise<void>
  }
}

function useAppState(): UseAppStateResult {
  // Комбинирует StoryService, StorageService и состояние UI
  // Единая точка управления состоянием приложения
  // Автосохранение с дебаунсом
}
```

3. `src/providers/StateProvider.tsx`:

```typescript
// Контекст для глобального состояния

interface StateContextValue {
  state: AppState
  dispatch: (action: StateAction) => void
  storage: StorageService
}

const StateContext = createContext<StateContextValue>()

export function StateProvider({ children }: { children: ComponentChildren }) {
  const [state, dispatch] = useReducer(stateReducer, initialState)
  const storage = useMemo(() => new StorageService(), [])

  // Синхронизация с localStorage
  useEffect(() => {
    // Восстановление при mount
    // Подписка на изменения в других вкладках
  }, [])

  return (
    <StateContext.Provider value={{ state, dispatch, storage }}>
      {children}
    </StateContext.Provider>
  )
}

// Reducer для управления состоянием
function stateReducer(state: AppState, action: StateAction): AppState {
  switch (action.type) {
    case 'SET_STORY_ID':
      return { ...state, currentStoryId: action.payload }
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload }
    case 'SET_ERROR':
      return { ...state, error: action.payload }
    case 'RESET':
      return initialState
    default:
      return state
  }
}
```

4. `src/utils/stateManagement.ts`:

```typescript
// Утилиты для работы с состоянием

// Дебаунс сохранения
function createDebouncedSaver(saveFunction: Function, delay: number = 500): Function

// Батчинг обновлений
function batchUpdates(updates: Array<() => void>): void

// Селекторы состояния
function selectCurrentStory(state: AppState): Story | null
function selectIsFirstStory(state: AppState): boolean
function selectIsLastStory(state: AppState): boolean

// Миграция старых данных
function migrateAppState(oldState: any): AppState | null

// Валидация состояния
function validateAppState(state: unknown): state is AppState
```

5. `tests/integration/statePersistence.test.tsx`:

```typescript
describe('State Persistence', () => {
  // Сохранение при навигации
  test('saves current story ID on navigation')

  // Восстановление при перезапуске
  test('restores last story on app restart')

  // Первый запуск
  test('shows first story on initial launch')

  // Невалидный сохраненный ID
  test('handles invalid saved story ID')

  // Недоступный localStorage
  test('works without localStorage')

  // Синхронизация вкладок
  test('syncs state between tabs')

  // Очистка состояния
  test('clears state on reset')

  // Производительность
  test('debounces frequent saves')
})
```

6. `tests/e2e/stateFlow.test.tsx`:

```typescript
// E2E тесты потока состояния
describe('State Flow E2E', () => {
  test('complete user journey with state persistence', async () => {
    // 1. Первый запуск - показывает историю 1
    // 2. Навигация к истории 100
    // 3. Закрытие приложения
    // 4. Повторное открытие - показывает историю 100
    // 5. Сброс состояния
    // 6. Показывает историю 1
  })

  test('multi-tab synchronization', async () => {
    // 1. Открыть в двух вкладках
    // 2. Навигация в первой вкладке
    // 3. Вторая вкладка обновляется
  })
})
```

АВТОСОХРАНЕНИЕ:

- Сохранять при каждой смене истории
- Дебаунс 500ms для частых переходов
- Не блокировать UI при сохранении
- Логировать ошибки, но не показывать пользователю

ИНИЦИАЛИЗАЦИЯ:

1. Показать loading screen
2. Загрузить истории
3. Восстановить последний ID
4. Проверить валидность ID
5. Показать историю или fallback на ID 1

ОБРАБОТКА ОСОБЫХ СЛУЧАЕВ:

- Первый запуск (нет сохраненного состояния)
- Удаленная история (ID больше не существует)
- Поврежденные данные в localStorage
- Переполнение localStorage
- Приватный режим браузера

Выведи полную интеграцию с приложением.

````

---

## Промпт M5.3: Расширенное управление состоянием

```text
Добавь расширенные возможности управления состоянием.

КОНТЕКСТ:
- Базовое сохранение последней истории работает
- Нужны дополнительные функции для улучшения UX
- Подготовка к будущим features (избранное, история чтения)

ЗАДАЧА:
1. Добавь расширенное состояние приложения
2. Реализуй историю чтения
3. Добавь статистику использования

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `src/types/state.ts` - расширенные типы состояния:
```typescript
interface ExtendedAppState {
  // Основное
  currentStoryId: number | null

  // История чтения
  readingHistory: ReadingHistoryEntry[]
  totalStoriesRead: number
  uniqueStoriesRead: Set<number>

  // Сессия
  sessionStartTime: number
  sessionStoriesRead: number
  lastActivityTime: number

  // Настройки (будущее)
  settings: {
    theme: 'light' | 'dark' | 'auto'
    fontSize: 'small' | 'medium' | 'large'
    swipeEnabled: boolean
    keyboardShortcutsEnabled: boolean
  }

  // Статистика
  stats: {
    totalReadingTime: number
    averageReadingSpeed: number
    favoriteReadingTime: string // время дня
    longestSession: number
    currentStreak: number
  }
}

interface ReadingHistoryEntry {
  storyId: number
  timestamp: number
  readingDuration?: number
  scrollPosition?: number
}
````

2. `src/services/readingTracker.ts`:

```typescript
// Сервис отслеживания чтения

class ReadingTracker {
  private startTime: number | null = null
  private currentStoryId: number | null = null
  private history: ReadingHistoryEntry[] = []
  private storage: StorageService

  // Начать отслеживание истории
  startReading(storyId: number): void

  // Завершить отслеживание
  endReading(): ReadingHistoryEntry | null

  // Получить историю чтения
  getHistory(limit?: number): ReadingHistoryEntry[]

  // Получить статистику
  getStats(): ReadingStats

  // Очистить историю
  clearHistory(): void

  // Экспорт данных
  exportData(): string

  // Импорт данных
  importData(data: string): boolean
}

interface ReadingStats {
  totalStories: number
  uniqueStories: number
  totalTime: number
  averageTime: number
  mostRead: number[]
  readingPattern: Map<number, number> // час дня -> количество
}
```

3. `src/components/ReadingStats.tsx` (опционально):

```typescript
// Компонент отображения статистики чтения

interface ReadingStatsProps {
  stats: ReadingStats
  isVisible: boolean
  onClose: () => void
}

// Показывает:
// - Всего прочитано историй
// - Уникальных историй
// - Время чтения
// - Любимое время для чтения
// - Текущая серия (streak)
```

4. `src/hooks/useReadingSession.ts`:

```typescript
// Хук для управления сессией чтения

interface UseReadingSessionResult {
  session: {
    duration: number
    storiesRead: number
    isActive: boolean
  }
  actions: {
    start: () => void
    pause: () => void
    resume: () => void
    end: () => void
  }
}

function useReadingSession(): UseReadingSessionResult {
  // Отслеживание активности
  // Автопауза при неактивности
  // Сохранение сессии
}

// Определение неактивности
function useIdleDetection(timeout: number, onIdle: () => void, onActive: () => void): void
```

5. `src/services/dataExport.ts`:

```typescript
// Сервис экспорта/импорта данных

class DataExportService {
  // Экспорт всех данных пользователя
  async exportAll(): Promise<ExportData>

  // Экспорт в JSON
  exportToJSON(data: ExportData): string

  // Экспорт в CSV (история чтения)
  exportToCSV(history: ReadingHistoryEntry[]): string

  // Импорт данных
  async importData(file: File): Promise<ImportResult>

  // Валидация импортируемых данных
  validateImportData(data: unknown): ValidationResult

  // Слияние с существующими данными
  mergeData(existing: ExportData, imported: ExportData): ExportData
}

interface ExportData {
  version: string
  exportDate: number
  appState: ExtendedAppState
  readingHistory: ReadingHistoryEntry[]
  settings: UserSettings
}
```

6. `src/utils/analytics.ts` (опционально):

```typescript
// Локальная аналитика (без отправки)

class LocalAnalytics {
  // Трекинг событий
  track(event: string, properties?: any): void

  // Анализ паттернов чтения
  analyzeReadingPatterns(): ReadingPattern

  // Рекомендации на основе истории
  getRecommendations(): number[]

  // Определение любимых историй
  getFavorites(threshold?: number): number[]
}

interface ReadingPattern {
  preferredTime: number // час дня
  averageSessionLength: number
  readingSpeed: number // истории в минуту
  skipPattern: number[] // часто пропускаемые ID
}
```

7. `tests/services/readingTracker.test.ts`:

```typescript
describe('ReadingTracker', () => {
  test('tracks reading duration')
  test('saves reading history')
  test('calculates statistics')
  test('handles interrupted sessions')
  test('exports and imports data')
  test('merges duplicate entries')
  test('limits history size')
})
```

PRIVACY & STORAGE:

- Все данные хранятся локально
- Опция полной очистки данных
- Экспорт для backup
- Лимит истории (последние 1000 записей)
- Сжатие старых данных

ОПТИМИЗАЦИЯ:

- Батчинг записи в localStorage
- Ленивая загрузка истории
- Очистка старых записей
- Индексация для быстрого поиска

Выведи реализацию расширенного состояния.

````

---

## Промпт M5.4: Синхронизация между вкладками

```text
Реализуй синхронизацию состояния между вкладками браузера.

КОНТЕКСТ:
- Пользователи могут открыть приложение в нескольких вкладках
- Состояние должно синхронизироваться в реальном времени
- Использовать BroadcastChannel API или storage events

ЗАДАЧА:
1. Реализуй межвкладочную коммуникацию
2. Синхронизируй навигацию и состояние
3. Обработай конфликты и race conditions

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `src/services/tabSync.ts`:
```typescript
// Сервис синхронизации вкладок

interface TabSyncOptions {
  channelName?: string
  syncDelay?: number
  conflictResolution?: 'last-write' | 'master-slave' | 'merge'
}

class TabSyncService {
  private channel: BroadcastChannel | null
  private storageListener: ((e: StorageEvent) => void) | null
  private tabId: string
  private isMaster: boolean
  private lastSync: number

  constructor(options?: TabSyncOptions)

  // Инициализация синхронизации
  init(): void

  // Отправка сообщения всем вкладкам
  broadcast(message: TabMessage): void

  // Подписка на сообщения
  subscribe(handler: (message: TabMessage) => void): () => void

  // Синхронизация состояния
  syncState(state: Partial<AppState>): void

  // Запрос состояния от других вкладок
  requestState(): Promise<AppState | null>

  // Определение master вкладки
  electMaster(): void

  // Очистка
  destroy(): void
}

interface TabMessage {
  type: 'state-update' | 'state-request' | 'state-response' |
        'master-election' | 'tab-closed' | 'keep-alive'
  tabId: string
  timestamp: number
  payload?: any
}

// Fallback для браузеров без BroadcastChannel
class StorageEventSync {
  // Использует localStorage events для синхронизации
  // Менее эффективно, но работает везде
}
````

2. `src/hooks/useTabSync.ts`:

```typescript
// Хук для синхронизации состояния между вкладками

interface UseTabSyncOptions {
  enabled?: boolean
  syncKeys?: string[] // какие части состояния синхронизировать
  onSync?: (state: any) => void
  onConflict?: (local: any, remote: any) => any
}

function useTabSync(
  state: any,
  setState: (state: any) => void,
  options?: UseTabSyncOptions
): {
  isConnected: boolean
  isMaster: boolean
  tabCount: number
  forceSync: () => void
}

// Использование:
// const { isMaster } = useTabSync(currentStoryId, setCurrentStoryId)
```

3. `src/utils/conflictResolution.ts`:

```typescript
// Стратегии разрешения конфликтов

// Последняя запись побеждает
function lastWriteWins<T>(local: T, remote: T, localTime: number, remoteTime: number): T

// Master-slave (одна вкладка главная)
function masterSlaveResolution<T>(local: T, remote: T, isMaster: boolean): T

// Слияние состояний
function mergeStates(local: AppState, remote: AppState): AppState {
  // Умное слияние:
  // - currentStoryId: берем более новый
  // - readingHistory: объединяем уникальные
  // - settings: последние изменения
  // - stats: суммируем
}

// Определение изменений
function detectChanges<T>(previous: T, current: T): Partial<T>

// Применение изменений
function applyChanges<T>(base: T, changes: Partial<T>): T
```

4. `src/components/TabIndicator.tsx`:

```typescript
// Индикатор активных вкладок

interface TabIndicatorProps {
  isVisible?: boolean
  position?: 'top-right' | 'bottom-right'
}

// Показывает:
// - Количество открытых вкладок
// - Индикатор master/slave
// - Статус синхронизации
// Минималистичный badge в углу
```

5. `src/services/heartbeat.ts`:

```typescript
// Сервис для отслеживания активных вкладок

class HeartbeatService {
  private interval: number | null = null
  private lastBeat: number = Date.now()

  // Начать отправку heartbeat
  start(intervalMs: number = 5000): void

  // Остановить
  stop(): void

  // Проверить активность вкладки
  isTabActive(tabId: string, threshold: number = 10000): boolean

  // Получить список активных вкладок
  getActiveTabs(): string[]

  // Очистить неактивные
  cleanupInactiveTabs(): void
}
```

6. `tests/services/tabSync.test.ts`:

```typescript
describe('TabSync Service', () => {
  // Базовая синхронизация
  test('syncs state between tabs')

  // BroadcastChannel
  test('uses BroadcastChannel when available')

  // Fallback на storage events
  test('falls back to storage events')

  // Master election
  test('elects master tab correctly')

  // Конфликты
  test('resolves conflicts with last-write-wins')
  test('resolves conflicts with master-slave')
  test('merges states correctly')

  // Heartbeat
  test('detects inactive tabs')
  test('cleans up on tab close')

  // Race conditions
  test('handles rapid state changes')
  test('handles simultaneous updates')
})
```

7. `tests/integration/multiTab.test.ts`:

```typescript
// Интеграционные тесты multi-tab
describe('Multi-tab Integration', () => {
  // Симуляция нескольких вкладок
  let tab1: MockTab
  let tab2: MockTab
  let tab3: MockTab

  test('navigation syncs across tabs')
  test('settings sync across tabs')
  test('reading history merges correctly')
  test('master tab takes precedence')
  test('handles tab closure gracefully')
  test('recovers from connection loss')
})
```

СТРАТЕГИИ СИНХРОНИЗАЦИИ:

1. **Immediate Sync** (немедленная)
   - currentStoryId
   - Критичные настройки

2. **Debounced Sync** (с задержкой)
   - Reading history
   - Statistics

3. **Manual Sync** (по запросу)
   - Export/Import
   - Full state reset

ОБРАБОТКА EDGE CASES:

- Вкладка открыта в приватном режиме
- BroadcastChannel недоступен
- Быстрое открытие/закрытие вкладок
- Конфликтующие изменения
- Потеря соединения
- Разные версии приложения в вкладках

ПРОИЗВОДИТЕЛЬНОСТЬ:

- Throttle частых обновлений
- Batch множественные изменения
- Использовать MessageChannel для больших данных
- Очистка старых сообщений

Выведи полную реализацию синхронизации.

````

---

## Промпт M5.5: Финальная интеграция и тестирование состояния

```text
Проведи финальную интеграцию всех компонентов управления состоянием.

КОНТЕКСТ:
- Реализованы: StorageService, ReadingTracker, TabSync
- Нужно объединить все в единую систему
- Обеспечить надежность и производительность

ЗАДАЧА:
1. Создай единый StateManager
2. Добавь миграции и версионирование
3. Проведи полное тестирование

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/services/stateManager.ts`:
```typescript
// Центральный менеджер состояния

class StateManager {
  private storage: StorageService
  private tracker: ReadingTracker
  private sync: TabSyncService
  private state: ExtendedAppState
  private subscribers: Set<StateSubscriber>

  constructor()

  // Инициализация всех сервисов
  async init(): Promise<void>

  // Получение состояния
  getState(): ExtendedAppState

  // Обновление состояния
  setState(updates: Partial<ExtendedAppState>): void

  // Подписка на изменения
  subscribe(subscriber: StateSubscriber): () => void

  // Действия
  actions = {
    navigateToStory: (id: number) => void
    markAsRead: (id: number) => void
    updateSettings: (settings: Partial<UserSettings>) => void
    clearHistory: () => void
    resetState: () => void
    exportData: () => Promise<string>
    importData: (data: string) => Promise<boolean>
  }

  // Очистка
  destroy(): void
}

type StateSubscriber = (state: ExtendedAppState) => void
````

2. `src/migrations/stateMigrations.ts`:

```typescript
// Миграции состояния между версиями

interface Migration {
  version: string
  up: (state: any) => any
  down?: (state: any) => any
}

const migrations: Migration[] = [
  {
    version: '1.0.0',
    up: (state) => ({
      ...state,
      version: '1.0.0',
    }),
  },
  {
    version: '1.1.0',
    up: (state) => ({
      ...state,
      readingHistory: state.history || [],
      version: '1.1.0',
    }),
  },
  {
    version: '1.2.0',
    up: (state) => ({
      ...state,
      settings: {
        theme: state.theme || 'auto',
        ...state.settings,
      },
      version: '1.2.0',
    }),
  },
]

// Применение миграций
function applyMigrations(state: any, fromVersion: string, toVersion: string): any

// Определение необходимых миграций
function getMigrationsToApply(currentVersion: string, targetVersion: string): Migration[]

// Валидация после миграции
function validateMigratedState(state: any): boolean
```

3. `src/hooks/useStateManager.ts`:

```typescript
// Главный хук для работы с состоянием

function useStateManager() {
  const manager = useRef<StateManager>()
  const [state, setState] = useState<ExtendedAppState>()
  const [isReady, setIsReady] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    // Инициализация
    manager.current = new StateManager()

    manager.current
      .init()
      .then(() => {
        setState(manager.current.getState())
        setIsReady(true)
      })
      .catch(setError)

    // Подписка на изменения
    const unsubscribe = manager.current.subscribe(setState)

    return () => {
      unsubscribe()
      manager.current?.destroy()
    }
  }, [])

  return {
    state,
    actions: manager.current?.actions,
    isReady,
    error,
  }
}
```

4. `src/utils/stateValidation.ts`:

```typescript
// Валидация и восстановление состояния

// Схема валидации состояния
const stateSchema = {
  currentStoryId: { type: 'number', nullable: true },
  readingHistory: { type: 'array', items: 'object' },
  settings: { type: 'object', required: true },
  // ...
}

// Валидация состояния
function validateState(state: unknown): ValidationResult

// Восстановление поврежденного состояния
function repairState(state: any): ExtendedAppState

// Создание состояния по умолчанию
function createDefaultState(): ExtendedAppState

// Проверка целостности
function checkStateIntegrity(state: ExtendedAppState): IntegrityReport

interface IntegrityReport {
  isValid: boolean
  errors: string[]
  warnings: string[]
  suggestions: string[]
}
```

5. `tests/stateManager.integration.test.ts`:

```typescript
describe('StateManager Integration', () => {
  // Полный жизненный цикл
  test('complete state lifecycle')

  // Миграции
  test('migrates from v1 to v2')
  test('handles corrupted migrations')

  // Синхронизация
  test('syncs all services')
  test('handles service failures')

  // Производительность
  test('handles 10k history entries')
  test('debounces frequent updates')

  // Восстановление
  test('recovers from corrupted state')
  test('repairs invalid data')

  // Export/Import
  test('exports complete state')
  test('imports and merges state')
})
```

6. `docs/STATE_MANAGEMENT.md`:

````markdown
# Управление состоянием

## Архитектура

- StateManager - центральный менеджер
- StorageService - персистентность
- ReadingTracker - отслеживание чтения
- TabSyncService - синхронизация вкладок

## Данные состояния

- currentStoryId - текущая история
- readingHistory - история чтения
- settings - настройки пользователя
- stats - статистика

## Миграции

Версии состояния и процесс миграции...

## API

```typescript
const { state, actions } = useStateManager()
actions.navigateToStory(123)
```
````

## Troubleshooting

- Очистка состояния: localStorage.clear()
- Экспорт для отладки: actions.exportData()
- Проверка целостности: checkStateIntegrity()

```

ЧЕКЛИСТ ГОТОВНОСТИ:
□ Состояние сохраняется при навигации
□ Восстанавливается при перезапуске
□ Синхронизируется между вкладками
□ История чтения работает
□ Миграции применяются корректно
□ Export/Import функционирует
□ Обработка ошибок покрыта
□ Производительность оптимальна
□ Документация complete

МЕТРИКИ КАЧЕСТВА:
- Время инициализации < 100ms
- Сохранение состояния < 50ms
- Синхронизация вкладок < 200ms
- Размер состояния < 1MB
- Покрытие тестами > 90%

Выведи финальную интеграцию и инструкции.
```

---

## Метаданные для LLM

Фаза M5 реализует полноценное управление состоянием приложения. Ключевые аспекты:

1. **Персистентность**: Сохранение состояния между сессиями
2. **Надежность**: Обработка всех edge cases и ошибок
3. **Расширяемость**: Готовность к добавлению новых features
4. **Синхронизация**: Работа с несколькими вкладками
5. **Производительность**: Оптимизация частых операций

После выполнения всех промптов M5:

- Приложение запоминает последнюю прочитанную историю
- Состояние восстанавливается при перезапуске
- Работает синхронизация между вкладками
- Есть расширенная статистика и история чтения
- Готовность к следующей фазе M6 (PWA и офлайн)
