# Серия промптов для фазы M3: Полный датасет

## Контекст для всех промптов фазы M3

Мы продолжаем работу над PWA приложением "ithappens". На данном этапе у нас есть работающее приложение с тестовым датасетом (20 историй). Сервис данных, навигация и UI компоненты полностью функционируют. Теперь нужно перейти на полный датасет (~26 МБ, 13,489 историй) с оптимизацией загрузки и обработкой ошибок.

---

## Промпт M3.1: Подготовка и миграция на полный датасет

````text
Подготовь приложение к работе с полным датасетом историй.

КОНТЕКСТ:
- Сейчас используется stories.json.sample (20 историй) для разработки
- Полный датасет stories.json (~26 МБ, 13,489 историй) будет в public/
- StoryService уже работает, но нужна оптимизация для большого объема
- Нужно поддерживать оба режима: dev (sample) и prod (full)

ЗАДАЧА:
1. Обнови конфигурацию для работы с разными датасетами
2. Создай тесты производительности для большого датасета
3. Подготовь StoryService к работе с большим объемом данных

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/config/app.config.ts`:
```typescript
interface AppConfig {
  storiesUrl: string
  isDevelopment: boolean
  enablePerformanceLogging: boolean
  maxLoadingTime: number // ms
  retryAttempts: number
  retryDelay: number // ms
}

// Определи URL на основе окружения
// DEV: /stories.json.sample
// PROD: /stories.json
````

2. `src/services/storyService.ts` - обновления:

```typescript
- Добавь метрики загрузки (время, размер)
- Оптимизируй индексацию для 13k+ записей
- Используй эффективные структуры данных
- Добавь прогресс загрузки (опционально)
```

3. `tests/performance/largeDataset.test.ts`:

```typescript
// Тесты с mock данными большого объема
- Время инициализации < 2 сек для 15k записей
- Потребление памяти стабильно
- Навигация остается мгновенной (< 50ms)
- Индексация ID эффективна
```

4. `src/utils/performance.ts`:

```typescript
// Утилиты для замера производительности
function measureExecutionTime<T>(fn: () => T | Promise<T>, label: string): Promise<T>

function getMemoryUsage(): MemoryInfo | null

function formatBytes(bytes: number): string

// Логирование только в dev режиме
```

5. `.env.example` и обновление `vite.config.ts`:

```env
VITE_USE_SAMPLE_DATA=true # для разработки
VITE_ENABLE_PERF_LOGGING=true
```

ТЕСТЫ:

- Mock тест с 15,000 записями (генерация в тесте)
- Замер времени парсинга JSON разных размеров
- Тест fallback на sample при ошибке загрузки full
- Проверка корректности индексации больших данных

ВАЖНО:

- Не коммить реальный stories.json (добавь в .gitignore)
- Создай инструкцию в README для размещения файла
- Подготовь placeholder файл stories.json.placeholder
- Убедись, что dev окружение продолжает работать с sample

Выведи все необходимые файлы и обновления.

````

---

## Промпт M3.2: Индикатор загрузки и состояния

```text
Реализуй индикатор загрузки для инициализации большого датасета.

КОНТЕКСТ:
- Загрузка 26 МБ может занять время на медленных соединениях
- Нужен простой текстовый индикатор (без анимаций по спецификации)
- Пользователь должен понимать, что происходит инициализация
- После загрузки индикатор должен исчезнуть

ЗАДАЧА:
1. Создай компонент LoadingScreen
2. Обнови App для показа состояния загрузки
3. Добавь тесты для различных состояний

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/components/LoadingScreen.tsx`:
```typescript
interface LoadingScreenProps {
  status: 'initializing' | 'loading' | 'parsing' | 'indexing'
  progress?: number // 0-100, опционально
  error?: Error | null
  onRetry?: () => void
}

// Минималистичный дизайн:
// - Центрированный текст
// - "Инициализация..." / "Загрузка историй..." и т.д.
// - Без спиннеров или анимаций
// - При ошибке: сообщение и кнопка "Повторить"
````

2. `src/components/LoadingScreen.module.css`:

```css
/* Полноэкранный оверлей */
/* Центрирование контента */
/* Минималистичная типографика */
/* Поддержка темной темы */
```

3. `src/hooks/useStoryService.ts` - новый хук:

```typescript
interface UseStoryServiceResult {
  service: StoryService | null
  isLoading: boolean
  loadingStatus: LoadingStatus
  error: Error | null
  retry: () => void
  progress?: number
}

// Инкапсулирует логику загрузки
// Отслеживает состояние
// Обрабатывает ошибки и повторы
```

4. `src/services/storyService.ts` - расширение:

```typescript
// Добавь события/коллбеки для отслеживания прогресса
interface LoadingCallbacks {
  onStatusChange?: (status: LoadingStatus) => void
  onProgress?: (progress: number) => void
}

async initializeWithCallbacks(
  url: string,
  callbacks?: LoadingCallbacks
): Promise<void>
```

5. `tests/components/LoadingScreen.test.tsx`:

```typescript
// Тесты отображения разных статусов
// Тест кнопки retry
// Тест доступности (aria-labels)
// Тест темной темы
```

6. `tests/hooks/useStoryService.test.ts`:

```typescript
// Тест успешной загрузки
// Тест обработки ошибок
// Тест retry логики
// Тест отмены при unmount
```

СОСТОЯНИЯ ЗАГРУЗКИ:

1. initializing - "Инициализация приложения..."
2. loading - "Загрузка историй..."
3. parsing - "Обработка данных..."
4. indexing - "Подготовка к работе..."
5. error - "Ошибка загрузки. [Повторить]"
6. ready - компонент скрыт

UX ТРЕБОВАНИЯ:

- Текст должен быть читаемым и понятным
- Избегать технических терминов
- При ошибке - понятное сообщение
- Кнопка retry крупная и доступная
- Поддержка клавиатуры (Enter для retry)

Выведи полную реализацию компонента и хука.

````

---

## Промпт M3.3: Оптимизация парсинга и обработка ошибок

```text
Оптимизируй процесс загрузки и парсинга большого JSON файла.

КОНТЕКСТ:
- JSON файл ~26 МБ может вызвать проблемы с памятью
- Парсинг большого JSON может заблокировать UI
- Нужна надежная обработка ошибок
- Возможны сетевые проблемы при загрузке

ЗАДАЧА:
1. Реализуй оптимизированную загрузку с обработкой ошибок
2. Добавь стратегии восстановления при сбоях
3. Создай тесты для edge cases

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/services/dataLoader.ts` - специализированный загрузчик:
```typescript
interface LoaderOptions {
  url: string
  timeout?: number
  retries?: number
  onProgress?: (loaded: number, total: number) => void
  signal?: AbortSignal
}

class DataLoader {
  // Загрузка с отслеживанием прогресса
  async fetchWithProgress(options: LoaderOptions): Promise<string>

  // Парсинг с обработкой ошибок
  async parseJSON<T>(text: string): Promise<T>

  // Валидация структуры данных
  validateStoriesData(data: unknown): data is StoriesData

  // Стратегия retry с exponential backoff
  async fetchWithRetry(options: LoaderOptions): Promise<string>
}

// Оптимизации:
// - Используй Response.body.getReader() для streaming
// - Отслеживай прогресс через loaded/total bytes
// - Прерывание через AbortController
// - Кэширование в sessionStorage для быстрого перезапуска
````

2. `src/utils/errorHandling.ts`:

```typescript
// Типы ошибок
class NetworkError extends Error {}
class ParseError extends Error {}
class ValidationError extends Error {}
class TimeoutError extends Error {}

// Определение типа ошибки и рекомендаций
function categorizeError(error: Error): {
  type: ErrorType
  userMessage: string
  canRetry: boolean
  suggestedAction: string
}

// Форматирование для пользователя
function formatErrorMessage(error: Error): string
```

3. `src/services/storageCache.ts` - кэширование для быстрого перезапуска:

```typescript
class StorageCache {
  // Сохранение в sessionStorage частями (обход лимита 5-10MB)
  async saveChunked(key: string, data: string): Promise<boolean>

  // Загрузка из sessionStorage
  async loadChunked(key: string): Promise<string | null>

  // Проверка актуальности (по хэшу или timestamp)
  isValid(key: string, maxAge?: number): boolean

  // Очистка
  clear(key: string): void
}

// Стратегия:
// 1. Проверить sessionStorage
// 2. Если есть и свежее - использовать
// 3. Иначе загрузить с сервера
// 4. Сохранить в кэш для быстрого перезапуска
```

4. `src/services/storyService.ts` - интеграция оптимизаций:

```typescript
class StoryService {
  private loader: DataLoader
  private cache: StorageCache

  async initialize(url: string): Promise<void> {
    try {
      // 1. Попытка загрузить из кэша
      const cached = await this.loadFromCache()
      if (cached) {
        await this.processData(cached)
        return
      }

      // 2. Загрузка с сервера
      const data = await this.loadFromNetwork(url)

      // 3. Сохранение в кэш
      await this.saveToCache(data)

      // 4. Обработка
      await this.processData(data)
    } catch (error) {
      throw this.handleError(error)
    }
  }
}
```

5. `tests/services/dataLoader.test.ts`:

```typescript
// Тест успешной загрузки
// Тест прогресса загрузки
// Тест прерывания через AbortSignal
// Тест retry при сетевых ошибках
// Тест timeout
// Тест невалидного JSON
// Тест частично загруженных данных
```

6. `tests/services/errorScenarios.test.ts`:

```typescript
// Сценарии ошибок:
// - Сеть недоступна (offline)
// - 404 файл не найден
// - 500 ошибка сервера
// - Поврежденный JSON
// - Неверная структура данных
// - Timeout при медленной сети
// - Недостаточно памяти
```

ОПТИМИЗАЦИИ:

- Streaming загрузка для уменьшения памяти
- Прогресс бар на основе байтов
- SessionStorage для быстрого перезапуска
- Graceful degradation при ошибках
- Четкие сообщения пользователю

ВАЖНО:

- Не блокировать UI при парсинге
- Поддержка отмены операции
- Fallback на sample data при критических ошибках
- Логирование ошибок в консоль (dev mode)

Выведи полную реализацию с обработкой всех edge cases.

````

---

## Промпт M3.4: Мониторинг производительности и памяти

```text
Добавь мониторинг производительности для работы с большим датасетом.

КОНТЕКСТ:
- Приложение загружает 26 МБ данных в память
- Нужно отслеживать потребление памяти и производительность
- В dev режиме показывать метрики
- В prod режиме только критические предупреждения

ЗАДАЧА:
1. Создай систему мониторинга производительности
2. Добавь dev-панель с метриками
3. Реализуй автоматические предупреждения

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `src/services/performanceMonitor.ts`:
```typescript
interface PerformanceMetrics {
  loadTime: number
  parseTime: number
  memoryUsed: number
  memoryDelta: number
  storyCount: number
  indexingTime: number
  firstRenderTime: number
}

class PerformanceMonitor {
  private metrics: Map<string, number>
  private enabled: boolean

  // Засечь начало операции
  startMeasure(label: string): void

  // Завершить замер
  endMeasure(label: string): number

  // Замер памяти
  measureMemory(): MemoryInfo

  // Сбор всех метрик
  getMetrics(): PerformanceMetrics

  // Проверка на проблемы
  checkHealth(): HealthStatus

  // Логирование в консоль (таблица)
  logMetrics(): void
}

interface HealthStatus {
  healthy: boolean
  warnings: string[]
  memoryPressure: boolean
}
````

2. `src/components/DevPanel.tsx` (только для dev):

```typescript
interface DevPanelProps {
  metrics: PerformanceMetrics | null
  isVisible: boolean
}

// Компактная панель в углу экрана
// Показывает:
// - Время загрузки
// - Использование памяти
// - Количество историй
// - FPS (опционально)
// Может сворачиваться/разворачиваться
```

3. `src/hooks/usePerformanceMonitor.ts`:

```typescript
function usePerformanceMonitor() {
  // Отслеживание метрик
  // Обновление каждые N секунд
  // Автоматические предупреждения

  return {
    metrics,
    health,
    startMeasure,
    endMeasure,
  }
}
```

4. `src/utils/memoryUtils.ts`:

```typescript
// Утилиты для работы с памятью
function estimateObjectSize(obj: any): number

function detectMemoryLeaks(baseline: number, current: number, threshold: number): boolean

function suggestOptimizations(metrics: PerformanceMetrics): string[]

// Проверка доступной памяти устройства
function getDeviceMemory(): number | null

// Рекомендации по оптимизации
function getOptimizationHints(metrics: PerformanceMetrics): {
  level: 'good' | 'warning' | 'critical'
  suggestions: string[]
}
```

5. `src/services/analyticsCollector.ts` (опционально):

```typescript
// Сбор анонимной статистики (только с согласия)
class AnalyticsCollector {
  // Время загрузки по percentiles
  // Размер памяти по устройствам
  // Частота ошибок

  collectAnonymous(metrics: PerformanceMetrics): void

  // Сохранение локально для анализа
  saveLocal(metrics: PerformanceMetrics): void

  // Экспорт для разработчиков
  exportMetrics(): string // CSV или JSON
}
```

6. `tests/performance/memoryLeaks.test.ts`:

```typescript
// Тест на утечки памяти при навигации
// Тест стабильности при долгой работе
// Тест граничных значений памяти
```

МЕТРИКИ ДЛЯ ОТСЛЕЖИВАНИЯ:

- Initial Load Time (до первого рендера)
- Time to Interactive (до готовности к работе)
- Memory Baseline (начальное потребление)
- Memory Peak (пиковое потребление)
- Parse Time (время парсинга JSON)
- Index Build Time (построение индексов)
- Navigation Speed (время перехода между историями)
- Render Time (время отрисовки истории)

ПОРОГОВЫЕ ЗНАЧЕНИЯ:

- Load Time: < 3s (warning), < 5s (critical)
- Memory: < 100MB (good), < 200MB (warning), > 200MB (critical)
- Navigation: < 50ms (good), < 100ms (warning)
- Parse Time: < 1s (good), < 2s (warning)

ВИЗУАЛИЗАЦИЯ (Dev Panel):

```
┌─────────────────────┐
│ 📊 Dev Metrics     ×│
├─────────────────────┤
│ Load: 2.3s         │
│ Memory: 45MB       │
│ Stories: 13,489    │
│ Parse: 0.8s        │
│ Status: ✅ Healthy  │
└─────────────────────┘
```

Выведи полную реализацию системы мониторинга.

````

---

## Промпт M3.5: Финальная интеграция и тестирование большого датасета

```text
Проведи финальную интеграцию всех оптимизаций для работы с полным датасетом.

КОНТЕКСТ:
- Реализованы: оптимизированный загрузчик, кэширование, мониторинг
- Нужно убедиться, что всё работает вместе
- Приложение должно быть готово к production нагрузке

ЗАДАЧА:
1. Интегрируй все компоненты фазы M3
2. Создай E2E тесты для полного флоу
3. Добавь документацию по работе с большими данными

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/app.tsx` - финальная интеграция:
```typescript
// Интеграция всех сервисов:
- DataLoader для загрузки
- StorageCache для кэширования
- PerformanceMonitor для метрик
- LoadingScreen для UI
- DevPanel для разработки
- ErrorBoundary для обработки критических ошибок
````

2. `tests/e2e/fullDataset.test.tsx`:

```typescript
// Полный сценарий с большим датасетом:
describe('Full Dataset Integration', () => {
  // Первая загрузка (холодный старт)
  test('loads 13k+ stories on first visit')

  // Повторная загрузка (из кэша)
  test('loads from cache on refresh')

  // Навигация по большому датасету
  test('navigates through stories efficiently')

  // Обработка ошибок
  test('handles network failure gracefully')

  // Восстановление после ошибки
  test('retries loading after error')

  // Производительность
  test('maintains performance with large dataset')

  // Память
  test('memory usage stays within limits')
})
```

3. `docs/LARGE_DATASET.md`:

```markdown
# Работа с большим датасетом

## Размещение файла данных

1. Скачайте stories.json (26 MB)
2. Поместите в public/stories.json
3. Проверьте: npm run validate-data

## Оптимизации

- Streaming загрузка
- SessionStorage кэширование
- Индексация ID при старте
- Lazy rendering

## Метрики производительности

- Target load time: < 3s
- Memory usage: < 100MB
- Navigation latency: < 50ms

## Troubleshooting

...
```

4. `scripts/validate-data.js`:

```javascript
// Скрипт валидации stories.json
// Проверяет:
// - Формат JSON
// - Структуру данных
// - Наличие обязательных полей
// - Размер файла
// - Количество историй
// Выводит статистику
```

5. `src/utils/dataValidator.ts`:

```typescript
interface ValidationResult {
  valid: boolean
  errors: string[]
  warnings: string[]
  stats: {
    totalStories: number
    fileSize: number
    minId: number
    maxId: number
    missingIds: number[]
    averageStoryLength: number
  }
}

function validateStoriesFile(data: unknown): ValidationResult
```

6. `.github/workflows/performance.yml`:

```yaml
# CI проверка производительности
name: Performance Tests
on: [push, pull_request]
jobs:
  performance:
    steps:
      - Generate large test dataset
      - Run performance tests
      - Check memory usage
      - Upload metrics as artifacts
      - Comment on PR with results
```

КОНТРОЛЬНЫЙ ЧЕКЛИСТ:
□ Приложение загружается < 3 сек с полным датасетом
□ Память не превышает 100MB после загрузки
□ Навигация остается мгновенной (< 50ms)
□ Кэширование работает (повторная загрузка быстрее)
□ Обработка ошибок покрывает все сценарии
□ DevPanel показывает корректные метрики
□ Нет утечек памяти при долгой работе
□ Все тесты проходят с большим датасетом
□ Документация описывает setup и troubleshooting

PRODUCTION READINESS:

1. Проверка на реальном устройстве (не эмулятор)
2. Тест на медленном 3G соединении
3. Тест при ограниченной памяти (бюджетные устройства)
4. Тест прерывания загрузки и восстановления
5. Тест обновления данных (новая версия stories.json)

ВАЖНО:

- Убедись, что dev режим продолжает работать с sample
- Production всегда использует полный датасет
- Graceful degradation при проблемах
- Четкие инструкции для разработчиков

Выведи финальную интеграцию и инструкции по тестированию.

````

---

## Промпт M3.6: Бенчмарки и оптимизация критических путей

```text
Создай бенчмарки и оптимизируй критические пути работы с данными.

КОНТЕКСТ:
- Приложение работает с полным датасетом
- Нужно найти и оптимизировать узкие места
- Обеспечить стабильную производительность на разных устройствах

ЗАДАЧА:
1. Создай набор бенчмарков
2. Профилируй критические операции
3. Примени оптимизации где необходимо

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `benchmarks/dataOperations.bench.ts`:
```typescript
// Бенчмарки с использованием vitest bench
import { bench, describe } from 'vitest'

describe('Data Operations', () => {
  bench('JSON.parse 26MB', () => {
    // Парсинг большого JSON
  })

  bench('Index building for 13k items', () => {
    // Построение индексов
  })

  bench('Binary search in sorted array', () => {
    // Поиск ID
  })

  bench('Map lookup vs Array find', () => {
    // Сравнение структур данных
  })

  bench('Memory allocation patterns', () => {
    // Паттерны выделения памяти
  })
})
````

2. `src/utils/optimizations.ts`:

```typescript
// Оптимизированные версии критических функций

// Бинарный поиск для отсортированных ID
function binarySearchId(ids: number[], target: number): number

// Ленивая инициализация больших объектов
class LazyMap<K, V> {
  private cache: Map<K, V>
  private loader: (key: K) => V

  get(key: K): V
}

// Дебаунс для частых операций
function debounce<T extends (...args: any[]) => any>(fn: T, delay: number): T

// Мемоизация для тяжелых вычислений
function memoize<T extends (...args: any[]) => any>(
  fn: T,
  keyFn?: (...args: Parameters<T>) => string
): T

// Chunking для обработки больших массивов
async function processInChunks<T, R>(
  items: T[],
  processor: (chunk: T[]) => Promise<R>,
  chunkSize: number = 100
): Promise<R[]>
```

3. `profiling/profile-report.md`:

```markdown
# Профилирование производительности

## Методология

- Chrome DevTools Performance
- Lighthouse CI
- User Timing API

## Результаты

### Критические пути

1. Initial data load: 2.3s
   - Network: 1.2s
   - Parse: 0.8s
   - Index: 0.3s

2. Navigation: 15ms
   - State update: 5ms
   - Render: 10ms

### Рекомендации по оптимизации

...
```

4. `src/workers/dataWorker.ts` (опционально):

```typescript
// Web Worker для тяжелых операций
// Вынос парсинга JSON в отдельный поток

self.addEventListener('message', async (e) => {
  const { type, payload } = e.data

  switch (type) {
    case 'PARSE_JSON':
      // Парсинг в фоновом потоке
      break
    case 'BUILD_INDEX':
      // Построение индексов
      break
  }
})
```

МЕТРИКИ ДЛЯ БЕНЧМАРКОВ:

- Operations per second (ops/s)
- Mean execution time (ms)
- Memory allocated (MB)
- GC pressure (collections/s)
- 95th percentile time

ЦЕЛЕВЫЕ ПОКАЗАТЕЛИ:

- Parse 26MB JSON: < 1000ms
- Build index 13k items: < 100ms
- Find story by ID: < 1ms
- Navigate to next: < 10ms
- Memory after load: < 100MB

Выведи бенчмарки и оптимизации.

```

---

## Метаданные для LLM

Фаза M3 фокусируется на переходе от тестового датасета к полному объему данных (26 МБ). Ключевые аспекты:

1. **Постепенность**: Сначала подготовка инфраструктуры, затем оптимизации, затем мониторинг
2. **Производительность**: Каждый промпт добавляет слой оптимизации
3. **Надежность**: Обработка ошибок, retry логика, fallback стратегии
4. **Измеримость**: Метрики, бенчмарки, профилирование
5. **Интеграция**: Все части работают вместе без конфликтов

После выполнения всех промптов M3:
- Приложение работает с полным датасетом 13,489 историй
- Загрузка оптимизирована и происходит < 3 секунд
- Память контролируется и не превышает 100MB
- Есть мониторинг производительности в dev режиме
- Обработка ошибок покрывает все edge cases
- Готовность к следующей фазе M4 (завершение UI/UX)
```
