# Серия промптов для фазы M2: Мини-датасет и сервис данных

## Контекст для всех промптов фазы M2

Мы работаем над PWA приложением "ithappens" для чтения историй. Используем **TypeScript**, **Preact**, **Vite**, **Vitest** для тестирования. Следуем TDD подходу - сначала тесты, потом реализация. На данный момент у нас есть базовый каркас приложения с тремя зонами (верх/контент/низ) и кнопками навигации без логики.

---

## Промпт M2.1: Создание тестового датасета

````text
Создай файл тестовых данных для приложения чтения историй.

КОНТЕКСТ:
- Приложение использует TypeScript и Preact
- Истории хранятся в JSON формате с числовыми ID в качестве ключей
- Некоторые ID могут быть пропущены (это важно для тестирования навигации)
- Файл будет использоваться для разработки и тестирования до подключения полного датасета

ТРЕБОВАНИЯ:
1. Создай файл `public/stories.json.sample` с 20 историями
2. Используй ID: 1, 2, 3, 5, 7, 8, 10, 12, 15, 18, 20, 22, 25, 28, 30, 33, 35, 38, 40, 42
   (обрати внимание на пропущенные ID: 4, 6, 9, 11, 13, 14, 16, 17, 19, 21...)
3. Каждая история должна быть короткой (2-4 предложения) но разной длины
4. Некоторые истории должны содержать переносы строк (\n)
5. Добавь одну длинную историю (10+ строк) для тестирования прокрутки

ФОРМАТ:
```json
{
  "1": "Текст первой истории",
  "2": "Текст второй истории с\nпереносом строки",
  ...
}
````

ДОПОЛНИТЕЛЬНО:

- Создай также TypeScript тип в `src/types/story.ts`:
  - StoriesData - тип для объекта историй
  - StoryId - тип для ID истории
- Добавь комментарии о назначении файла и его временном характере

Выведи готовые файлы с понятным тестовым контентом на русском языке.

````

---

## Промпт M2.2: Реализация storyService с тестами

```text
Реализуй сервис для работы с историями, используя TDD подход.

КОНТЕКСТ:
- У нас есть файл `public/stories.json.sample` с тестовыми данными (20 историй с пропусками ID)
- Типы определены в `src/types/story.ts`: StoriesData, StoryId
- Используем Vitest для тестирования
- Сервис должен загружать данные при инициализации и индексировать существующие ID

ЗАДАЧА:
1. СНАЧАЛА создай тесты в `tests/services/storyService.test.ts`
2. ПОТОМ реализуй сервис в `src/services/storyService.ts`

ТЕСТЫ должны покрывать:
- Инициализацию сервиса и загрузку данных
- getById(id) - получение истории по ID (существующий и несуществующий)
- getNextId(currentId) - получение следующего существующего ID с учетом пропусков
- getPrevId(currentId) - получение предыдущего существующего ID с учетом пропусков
- getFirstId() - получение первого ID
- getLastId() - получение последнего ID
- getAllIds() - получение массива всех существующих ID
- Цикличность: после последнего ID идет первый, перед первым - последний
- Обработку ошибок загрузки данных

API СЕРВИСА:
```typescript
class StoryService {
  async initialize(url: string): Promise<void>
  getById(id: StoryId): string | null
  getNextId(currentId: StoryId): StoryId | null
  getPrevId(currentId: StoryId): StoryId | null
  getFirstId(): StoryId | null
  getLastId(): StoryId | null
  getAllIds(): StoryId[]
  isLoaded(): boolean
}
````

ВАЖНО:

- Используй Map или Set для эффективной индексации ID
- Обработай случай пустых данных
- Для тестов используй mock данные, не загружай реальный файл
- Следуй принципу "красный-зеленый-рефакторинг"

Выведи сначала полный файл тестов, затем реализацию сервиса.

````

---

## Промпт M2.3: Утилиты навигации с тестами

```text
Создай утилиты навигации для вычисления переходов между историями.

КОНТЕКСТ:
- У нас есть StoryService с методами getNextId/getPrevId
- Нужны чистые функции для логики навигации с поддержкой цикличности
- Эти функции будут использоваться в компонентах для управления состоянием

ЗАДАЧА:
1. СНАЧАЛА создай тесты в `tests/utils/navigation.test.ts`
2. ПОТОМ реализуй утилиты в `src/utils/navigation.ts`

ФУНКЦИИ:
```typescript
// Вычисляет ID следующей истории с учетом цикличности
function calculateNextStoryId(
  currentId: StoryId,
  availableIds: StoryId[]
): StoryId | null

// Вычисляет ID предыдущей истории с учетом цикличности
function calculatePrevStoryId(
  currentId: StoryId,
  availableIds: StoryId[]
): StoryId | null

// Проверяет, можно ли перейти вперед (для disabled состояния кнопки)
function canGoNext(
  currentId: StoryId,
  availableIds: StoryId[]
): boolean

// Проверяет, можно ли перейти назад (для disabled состояния кнопки)
function canGoPrev(
  currentId: StoryId,
  availableIds: StoryId[]
): boolean

// Находит ближайший существующий ID (для перехода по несуществующему ID)
function findClosestExistingId(
  targetId: StoryId,
  availableIds: StoryId[]
): StoryId | null

// Валидирует ID для модального окна
function validateStoryId(
  input: string,
  availableIds: StoryId[]
): { valid: boolean; id?: StoryId; error?: string }
````

ТЕСТ-КЕЙСЫ:

- Обычная навигация вперед/назад
- Цикличность (с последнего на первый, с первого на последний)
- Пропуски ID (например, с ID 3 на ID 5, если 4 не существует)
- Граничные случаи (пустой массив, один элемент, несуществующий currentId)
- Валидация ввода (пустой, не число, отрицательный, несуществующий ID)
- Поиск ближайшего ID (вверх и вниз)

ВАЖНО:

- Функции должны быть чистыми (без побочных эффектов)
- Не зависеть от StoryService напрямую (принимают массив ID)
- Эффективная работа с большими массивами (бинарный поиск где уместно)

Выведи полные файлы с тестами и реализацией.

````

---

## Промпт M2.4: Интеграция с UI компонентами

```text
Интегрируй сервис данных и навигацию с существующими UI компонентами.

КОНТЕКСТ:
- У нас есть StoryService для работы с данными
- Есть утилиты навигации в navigation.ts
- Существуют компоненты StoryViewer и Navigation (заглушки)
- Нужно связать всё вместе в работающее приложение

ЗАДАЧА:
1. Обнови главный компонент App с состоянием и логикой
2. Создай тесты интеграции в `tests/integration/navigation.test.tsx`
3. Обнови компоненты для работы с реальными данными

ФАЙЛЫ ДЛЯ ОБНОВЛЕНИЯ:

1. `src/app.tsx` - главный компонент:
```typescript
- Инициализация StoryService при монтировании
- Состояние: currentStoryId, isLoading, error
- Обработчики: handleNext, handlePrev, handleJumpToId
- Передача props в дочерние компоненты
- Показ состояния загрузки/ошибки
````

2. `src/components/StoryViewer.tsx`:

```typescript
interface StoryViewerProps {
  storyId: StoryId | null
  storyText: string | null
  isLoading: boolean
}
- Отображение ID истории
- Рендер текста с сохранением \n
- Состояние загрузки
```

3. `src/components/Navigation.tsx`:

```typescript
interface NavigationProps {
  onNext: () => void
  onPrev: () => void
  onJumpClick: () => void
  canGoNext: boolean
  canGoPrev: boolean
}
- Кнопки с обработчиками
- Disabled состояния
- Клавиатурные сокращения (useEffect для стрелок)
```

ИНТЕГРАЦИОННЫЕ ТЕСТЫ:

- Загрузка первой истории при старте
- Навигация кнопками вперед/назад
- Цикличность навигации
- Disabled состояния на краях (хотя у нас цикличность)
- Клавиатурная навигация (симуляция нажатий стрелок)
- Обработка состояния загрузки
- Обработка ошибок загрузки

ВАЖНО:

- Используй хуки Preact (useState, useEffect, useCallback)
- Мемоизируй обработчики где необходимо
- Обеспечь типобезопасность через TypeScript
- Следи за тем, чтобы не было "висящего" кода из предыдущих шагов
- Убедись, что приложение полностью работает с тестовыми данными

Выведи обновленные файлы компонентов и тесты интеграции.

````

---

## Промпт M2.5: Финальная проверка и рефакторинг

```text
Проведи финальную проверку интеграции и рефакторинг кода фазы M2.

КОНТЕКСТ:
- Реализованы: storyService, navigation utils, обновлены компоненты
- Приложение должно полностью работать с тестовым датасетом
- Все части должны быть интегрированы без "висящего" кода

ЗАДАЧА:
1. Проверь полную интеграцию всех компонентов
2. Добавь недостающие экспорты/импорты
3. Создай smoke test для полного флоу
4. Обнови package.json скрипты если нужно

ЧЕКЛИСТ ПРОВЕРКИ:
□ StoryService корректно загружает stories.json.sample
□ Навигация работает с учетом пропусков ID
□ Цикличность работает (последний ↔ первый)
□ UI отображает текущую историю
□ Кнопки вперед/назад функционируют
□ Клавиатурные стрелки работают
□ Состояние загрузки отображается
□ Ошибки обрабатываются gracefully
□ Все тесты проходят (unit + integration)
□ TypeScript компилируется без ошибок

СОЗДАЙ:
1. `tests/smoke/app.smoke.test.tsx` - E2E-подобный тест:
   - Монтирование приложения
   - Ожидание загрузки
   - Навигация через несколько историй
   - Проверка цикличности
   - Базовая проверка рендера

2. `src/main.tsx` - точка входа (если не создана):
   - Монтирование App в #root
   - Обработка ошибок верхнего уровня

3. README секцию "Development Progress":
   - [x] M0: Bootstrap and quality setup
   - [x] M1: UI skeleton
   - [x] M2: Mini-dataset and data service ← МЫ ЗДЕСЬ
   - [ ] M3: Full dataset
   - [ ] M4: Complete UI/UX
   - ...

ВАЖНО:
- Убедись, что `npm run dev` запускает работающее приложение
- `npm test` должен проходить все тесты
- Не должно быть неиспользуемого кода
- Все файлы должны быть связаны в единую систему

Выведи финальные файлы и инструкции для проверки работоспособности.
````

---

## Метаданные для LLM

Каждый промпт в этой серии:

1. **Основывается на предыдущем** - каждый следующий шаг использует код из предыдущего
2. **Включает тесты** - TDD подход, сначала тесты, потом реализация
3. **Постепенно наращивает сложность** - от данных к сервису, от сервиса к UI
4. **Интегрирует всё вместе** - финальный промпт проверяет полную интеграцию
5. **Не оставляет "висящего" кода** - каждая часть связана с остальными

После выполнения всех промптов M2, приложение должно полностью работать с тестовым датасетом, обеспечивая солидную основу для следующих фаз (M3: полный датасет, M4: завершение UI, и т.д.).
