# Серия промптов для фазы M4: Завершение UI/UX

## Контекст для всех промптов фазы M4

Приложение "ithappens" полностью работает с большим датасетом (13,489 историй). Сервисы данных оптимизированы, производительность под контролем. Теперь нужно довести UI/UX до production качества: корректное отображение текста, модальное окно перехода, клавиатурная навигация и поддержка темной темы.

---

## Промпт M4.1: Улучшение StoryViewer с форматированием текста

````text
Доработай компонент StoryViewer для корректного отображения историй.

КОНТЕКСТ:
- Компонент уже отображает текст историй
- Нужно правильно обрабатывать переносы строк (\n)
- Длинные истории должны прокручиваться
- Сохранить минималистичный дизайн

ЗАДАЧА:
1. Обнови StoryViewer для правильного форматирования
2. Добавь поддержку длинных текстов с прокруткой
3. Создай тесты для различных форматов текста

ФАЙЛЫ ДЛЯ ОБНОВЛЕНИЯ/СОЗДАНИЯ:

1. `src/components/StoryViewer.tsx`:
```typescript
interface StoryViewerProps {
  storyId: number | null
  storyText: string | null
  isLoading: boolean
  error?: Error | null
}

// Компонент должен:
// - Конвертировать \n в <br/> или использовать white-space: pre-wrap
// - Показывать ID истории в верхней части
// - Обеспечивать вертикальную прокрутку для длинных текстов
// - Сохранять позицию прокрутки при навигации (опционально)
// - Правильно обрабатывать специальные символы
````

2. `src/components/StoryViewer.module.css`:

```css
/* Стили для области контента */
.container {
  /* Фиксированная высота с учетом header и navigation */
  /* flex: 1 для заполнения доступного пространства */
}

.header {
  /* Фиксированная высота */
  /* Отображение ID */
  /* Граница снизу */
}

.content {
  /* Прокручиваемая область */
  /* overflow-y: auto */
  /* Отступы для читаемости */
  /* Оптимальная ширина строки (max-width) */
}

.text {
  /* white-space: pre-wrap для сохранения форматирования */
  /* line-height для читаемости */
  /* font-size оптимальный для мобильных */
}

/* Стили для состояний */
.loading {
}
.error {
}
.empty {
}

/* Scrollbar стилизация (опционально) */
.content::-webkit-scrollbar {
}
```

3. `src/hooks/useScrollReset.ts`:

```typescript
// Хук для управления прокруткой
interface UseScrollResetOptions {
  resetOn?: any[] // зависимости для сброса
  preservePosition?: boolean // сохранять позицию
}

function useScrollReset(ref: RefObject<HTMLElement>, options?: UseScrollResetOptions): void

// Логика:
// - Сброс прокрутки при смене истории
// - Опционально: сохранение позиции при навигации назад
```

4. `src/utils/textFormatting.ts`:

```typescript
// Утилиты форматирования текста

// Безопасное преобразование переносов строк
function formatLineBreaks(text: string): string

// Escape специальных HTML символов
function escapeHtml(text: string): string

// Определение "длинной" истории
function isLongStory(text: string, threshold?: number): boolean

// Подсчет строк в тексте
function countLines(text: string): number

// Обрезка текста с многоточием (для превью, если нужно)
function truncateText(text: string, maxLength: number, suffix?: string): string
```

5. `tests/components/StoryViewer.test.tsx`:

```typescript
describe('StoryViewer', () => {
  // Рендер с обычным текстом
  test('renders story text with ID')

  // Сохранение переносов строк
  test('preserves line breaks in text')

  // Длинные истории прокручиваются
  test('enables scrolling for long stories')

  // Специальные символы экранируются
  test('escapes HTML special characters')

  // Состояние загрузки
  test('shows loading state')

  // Состояние ошибки
  test('displays error message')

  // Пустое состояние
  test('handles null/empty story')

  // Сброс прокрутки при смене истории
  test('resets scroll position on story change')
})
```

6. `tests/utils/textFormatting.test.ts`:

```typescript
// Тесты утилит форматирования
describe('Text Formatting', () => {
  test('converts \\n to proper line breaks')
  test('escapes < > & characters')
  test('counts lines correctly')
  test('identifies long stories')
  test('truncates text with ellipsis')
})
```

ТРЕБОВАНИЯ К UI:

- Фиксированный ID вверху всегда видим
- Текст не должен быть слишком широким (max-width ~800px)
- Оптимальный размер шрифта для чтения (16-18px)
- Достаточный line-height (1.5-1.6)
- Padding для комфортного чтения на мобильных
- Плавная прокрутка (smooth scrolling)

ДОСТУПНОСТЬ:

- role="article" для области контента
- aria-label с ID истории
- Фокус на контенте для screen readers
- Правильная табуляция

Выведи полную реализацию компонента с тестами.

````

---

## Промпт M4.2: Модальное окно перехода по ID

```text
Реализуй модальное окно для перехода к истории по ID.

КОНТЕКСТ:
- Нужно окно с полем ввода для перехода к конкретной истории
- Валидация существования ID
- Закрытие по клику вне окна, ESC, кнопке закрытия
- Минималистичный дизайн без лишних анимаций

ЗАДАЧА:
1. Создай компонент JumpModal
2. Реализуй логику валидации и перехода
3. Добавь управление фокусом и доступность

ФАЙЛЫ ДЛЯ СОЗДАНИЯ:

1. `src/components/JumpModal.tsx`:
```typescript
interface JumpModalProps {
  isOpen: boolean
  onClose: () => void
  onJump: (id: number) => void
  availableIds: number[]
  currentId: number
}

// Компонент должен:
// - Показывать overlay при isOpen=true
// - Автофокус на поле ввода при открытии
// - Валидация в реальном времени
// - Сообщения об ошибках (несуществующий ID)
// - Закрытие по ESC, клику на overlay, кнопке X
// - Подтверждение по Enter в поле
// - Trap фокуса внутри модала
````

2. `src/components/JumpModal.module.css`:

```css
/* Overlay */
.overlay {
  /* position: fixed, полное покрытие */
  /* background с прозрачностью */
  /* z-index для наложения */
  /* display: flex для центрирования */
}

/* Модальное окно */
.modal {
  /* background: белый/темный в зависимости от темы */
  /* padding, border-radius */
  /* min/max размеры */
  /* box-shadow для глубины */
}

/* Заголовок */
.header {
  /* display: flex, justify-content: space-between */
  /* Заголовок + кнопка закрытия */
}

/* Форма */
.form {
  /* Поле ввода + кнопка перехода */
  /* gap между элементами */
}

/* Поле ввода */
.input {
  /* Крупный размер для мобильных */
  /* inputmode="numeric" для цифровой клавиатуры */
  /* Стили для valid/invalid состояний */
}

/* Сообщение об ошибке */
.error {
  /* color: error */
  /* font-size: smaller */
  /* margin-top */
}

/* Кнопки */
.button {
  /* Стандартные стили кнопок */
  /* :disabled состояние */
}

.closeButton {
  /* Кнопка X в углу */
  /* Только иконка, без текста */
}
```

3. `src/hooks/useModal.ts`:

```typescript
interface UseModalOptions {
  onEscape?: () => void
  onClickOutside?: () => void
  trapFocus?: boolean
  restoreFocus?: boolean
}

function useModal(
  isOpen: boolean,
  options?: UseModalOptions
): {
  modalRef: RefObject<HTMLDivElement>
  handleKeyDown: (e: KeyboardEvent) => void
  handleOverlayClick: (e: MouseEvent) => void
}

// Функционал:
// - Обработка ESC
// - Клик вне модала
// - Focus trap (табуляция внутри модала)
// - Восстановление фокуса после закрытия
```

4. `src/hooks/useFocusTrap.ts`:

```typescript
// Хук для удержания фокуса внутри элемента
function useFocusTrap(containerRef: RefObject<HTMLElement>, isActive: boolean): void

// Логика:
// - Найти все focusable элементы
// - Перехват Tab/Shift+Tab
// - Циклическая навигация
// - Автофокус на первый элемент
```

5. `src/utils/validation.ts`:

```typescript
// Валидация ввода ID

interface ValidationResult {
  isValid: boolean
  value?: number
  error?: string
}

// Валидация строки как ID истории
function validateStoryIdInput(input: string, availableIds: number[]): ValidationResult

// Проверка существования ID
function isValidStoryId(id: number, availableIds: number[]): boolean

// Форматирование ввода (удаление пробелов и т.д.)
function sanitizeInput(input: string): string

// Получение подсказки для пользователя
function getValidationHint(input: string, availableIds: number[]): string
```

6. `tests/components/JumpModal.test.tsx`:

```typescript
describe('JumpModal', () => {
  // Открытие/закрытие
  test('opens and closes correctly')

  // Автофокус на поле
  test('autofocuses input on open')

  // Валидация валидного ID
  test('accepts valid story ID')

  // Отклонение невалидного ID
  test('shows error for invalid ID')

  // Закрытие по ESC
  test('closes on Escape key')

  // Закрытие по клику на overlay
  test('closes on overlay click')

  // Не закрывается при клике внутри
  test('does not close on modal content click')

  // Переход по Enter
  test('jumps to story on Enter')

  // Focus trap работает
  test('traps focus within modal')

  // Восстановление фокуса
  test('restores focus after close')
})
```

7. `tests/hooks/useModal.test.ts`:

```typescript
// Тесты хука модального окна
test('calls onEscape when Escape pressed')
test('calls onClickOutside for overlay clicks')
test('ignores clicks inside modal')
```

ТРЕБОВАНИЯ UX:

- Поле ввода крупное (min-height: 48px для мобильных)
- inputmode="numeric" для показа цифровой клавиатуры
- Placeholder с подсказкой (например: "Введите ID от 1 до 13489")
- Мгновенная валидация при вводе
- Четкие сообщения об ошибках
- Кнопка "Перейти" активна только при валидном ID

ДОСТУПНОСТЬ:

- role="dialog" и aria-modal="true"
- aria-labelledby для заголовка
- aria-describedby для ошибок
- aria-invalid для невалидного поля
- Правильный focus management

Выведи полную реализацию модального окна.

````

---

## Промпт M4.3: Клавиатурная навигация

```text
Добавь полноценную поддержку клавиатурной навигации.

КОНТЕКСТ:
- Основная навигация стрелками влево/вправо уже частично реализована
- Нужно добавить дополнительные shortcuts и улучшить UX
- Избежать конфликтов с модальным окном и другими элементами

ЗАДАЧА:
1. Реализуй глобальную клавиатурную навигацию
2. Добавь визуальные подсказки о горячих клавишах
3. Обработай edge cases и конфликты

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/hooks/useKeyboardNavigation.ts`:
```typescript
interface KeyboardShortcuts {
  next: string[]        // ['ArrowRight', 'd']
  previous: string[]    // ['ArrowLeft', 'a']
  jump: string[]        // ['j', 'g']
  first: string[]       // ['Home', '0']
  last: string[]        // ['End', '$']
  help: string[]        // ['?', 'h']
}

interface UseKeyboardNavigationOptions {
  enabled?: boolean
  shortcuts?: Partial<KeyboardShortcuts>
  preventDefault?: boolean
  stopPropagation?: boolean
}

function useKeyboardNavigation(
  handlers: {
    onNext: () => void
    onPrevious: () => void
    onJump?: () => void
    onFirst?: () => void
    onLast?: () => void
    onHelp?: () => void
  },
  options?: UseKeyboardNavigationOptions
): {
  isEnabled: boolean
  shortcuts: KeyboardShortcuts
  disable: () => void
  enable: () => void
}

// Логика:
// - Регистрация глобальных listeners
// - Игнорирование при фокусе на input/textarea
// - Отключение при открытом модале
// - Поддержка множественных shortcuts для одного действия
````

2. `src/components/KeyboardHelp.tsx`:

```typescript
interface KeyboardHelpProps {
  isVisible: boolean
  onClose: () => void
  shortcuts: KeyboardShortcuts
}

// Компонент показывает список горячих клавиш
// Может быть:
// - Tooltip при наведении на кнопку "?"
// - Маленькое модальное окно
// - Collapsible панель внизу
```

3. `src/components/KeyboardHelp.module.css`:

```css
.container {
  /* Позиционирование */
  /* Компактный размер */
}

.shortcutList {
  /* display: grid или flex */
  /* gap между items */
}

.shortcutItem {
  /* display: flex */
  /* justify-content: space-between */
}

.key {
  /* Стиль для отображения клавиши */
  /* border, border-radius */
  /* font-family: monospace */
  /* padding для вида кнопки */
}

.description {
  /* Описание действия */
}

/* Анимация появления (опционально) */
.container[data-visible='true'] {
  /* transition для плавности */
}
```

4. `src/contexts/KeyboardContext.tsx`:

```typescript
// Контекст для управления клавиатурной навигацией глобально

interface KeyboardContextValue {
  isEnabled: boolean
  shortcuts: KeyboardShortcuts
  registerHandler: (key: string, handler: () => void) => void
  unregisterHandler: (key: string) => void
  temporarilyDisable: () => () => void // возвращает функцию восстановления
}

const KeyboardContext = createContext<KeyboardContextValue>()

export function KeyboardProvider({ children }: { children: ComponentChildren }) {
  // Централизованное управление shortcuts
  // Приоритеты обработчиков
  // Временное отключение для модалов
}

export function useKeyboard() {
  return useContext(KeyboardContext)
}
```

5. `src/utils/keyboardUtils.ts`:

```typescript
// Утилиты для работы с клавиатурой

// Нормализация key codes
function normalizeKey(event: KeyboardEvent): string

// Проверка, является ли элемент вводимым
function isInputElement(element: Element): boolean

// Проверка модификаторов
function hasModifier(event: KeyboardEvent): boolean

// Форматирование клавиши для отображения
function formatKeyForDisplay(key: string): string {
  // ArrowLeft → ←
  // Enter → ⏎
  // Space → ␣
}

// Определение ОС для правильных shortcuts
function getOSShortcuts(): {
  copy: string
  paste: string
  // ...
}

// Проверка поддержки клавиши
function isKeySupported(key: string): boolean
```

6. `tests/hooks/useKeyboardNavigation.test.ts`:

```typescript
describe('useKeyboardNavigation', () => {
  // Навигация стрелками
  test('navigates with arrow keys')

  // Альтернативные shortcuts (a/d)
  test('supports alternative shortcuts')

  // Игнорирование в input
  test('ignores shortcuts when input focused')

  // Отключение/включение
  test('can be disabled and enabled')

  // Home/End навигация
  test('jumps to first/last with Home/End')

  // Предотвращение default
  test('prevents default browser behavior')

  // Множественные handlers
  test('handles multiple shortcuts for same action')
})
```

7. `tests/integration/keyboardFlow.test.tsx`:

```typescript
// Интеграционные тесты клавиатурной навигации
describe('Keyboard Navigation Flow', () => {
  test('complete navigation with keyboard only')
  test('keyboard shortcuts with modal open')
  test('help dialog shows and hides')
  test('conflicts are resolved correctly')
})
```

СПИСОК SHORTCUTS:

- `→` или `d` - следующая история
- `←` или `a` - предыдущая история
- `j` или `g` - открыть окно перехода
- `Home` или `0` - первая история
- `End` или `$` - последняя история
- `?` или `h` - показать help
- `Esc` - закрыть модалы/help

ТРЕБОВАНИЯ:

- Не конфликтовать с браузерными shortcuts
- Работать на разных раскладках
- Отключаться при вводе текста
- Показывать hints в UI (опционально)
- Поддержка touch-устройств (скрыть shortcuts)

ВИЗУАЛЬНЫЕ ПОДСКАЗКИ:

- Маленькие hints на кнопках навигации
- Help иконка с списком shortcuts
- Toast при первом использовании (опционально)

Выведи полную реализацию клавиатурной навигации.

````

---

## Промпт M4.4: Темы оформления (светлая/темная)

```text
Реализуй поддержку светлой и темной тем с автоматическим переключением.

КОНТЕКСТ:
- Приложение должно поддерживать обе темы
- Автоматическое переключение по системным настройкам
- Минималистичный дизайн в обеих темах
- CSS переменные для управления цветами

ЗАДАЧА:
1. Настрой систему тем через CSS переменные
2. Реализуй автоматическое определение темы
3. Добавь опциональное ручное переключение

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/styles/themes.css`:
```css
/* Корневые переменные для светлой темы */
:root {
  /* Основные цвета */
  --color-bg-primary: #ffffff;
  --color-bg-secondary: #f5f5f5;
  --color-bg-overlay: rgba(0, 0, 0, 0.5);

  /* Текст */
  --color-text-primary: #333333;
  --color-text-secondary: #666666;
  --color-text-muted: #999999;

  /* Границы */
  --color-border: #e0e0e0;
  --color-border-focus: #4a90e2;

  /* Кнопки */
  --color-button-bg: #f0f0f0;
  --color-button-bg-hover: #e8e8e8;
  --color-button-bg-active: #d0d0d0;
  --color-button-text: #333333;

  /* Состояния */
  --color-error: #d32f2f;
  --color-success: #388e3c;
  --color-warning: #f57c00;
  --color-info: #1976d2;

  /* Тени */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.16);
  --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.19);

  /* Прочее */
  --border-radius: 4px;
  --transition-duration: 200ms;
}

/* Темная тема */
@media (prefers-color-scheme: dark) {
  :root {
    --color-bg-primary: #1a1a1a;
    --color-bg-secondary: #2a2a2a;
    --color-bg-overlay: rgba(0, 0, 0, 0.7);

    --color-text-primary: #e0e0e0;
    --color-text-secondary: #b0b0b0;
    --color-text-muted: #808080;

    --color-border: #404040;
    --color-border-focus: #5a9fd4;

    --color-button-bg: #2a2a2a;
    --color-button-bg-hover: #3a3a3a;
    --color-button-bg-active: #4a4a4a;
    --color-button-text: #e0e0e0;

    /* Приглушенные цвета для темной темы */
    --color-error: #f44336;
    --color-success: #4caf50;
    --color-warning: #ff9800;
    --color-info: #2196f3;

    --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.24);
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.32);
    --shadow-lg: 0 10px 20px rgba(0, 0, 0, 0.38);
  }
}

/* Классы для принудительных тем */
[data-theme="light"] {
  /* Светлая тема */
}

[data-theme="dark"] {
  /* Темная тема */
}
````

2. `src/hooks/useTheme.ts`:

```typescript
type Theme = 'light' | 'dark' | 'auto'

interface UseThemeResult {
  theme: Theme
  resolvedTheme: 'light' | 'dark'
  setTheme: (theme: Theme) => void
  toggleTheme: () => void
  systemTheme: 'light' | 'dark'
}

function useTheme(): UseThemeResult {
  // Определение системной темы
  // Сохранение выбора в localStorage
  // Применение темы к document
  // Слушатель изменений системной темы
}

// Логика:
// 1. Проверить localStorage для сохраненной темы
// 2. Если auto или не задано - использовать системную
// 3. Применить через data-theme атрибут
// 4. Слушать изменения prefers-color-scheme
```

3. `src/components/ThemeToggle.tsx` (опционально):

```typescript
interface ThemeToggleProps {
  className?: string
  showLabel?: boolean
}

// Компонент переключения темы
// Может быть:
// - Простая кнопка с иконкой солнца/луны
// - Toggle switch
// - Dropdown с тремя опциями (light/dark/auto)
```

4. `src/utils/themeUtils.ts`:

```typescript
// Утилиты для работы с темами

// Определение системной темы
function getSystemTheme(): 'light' | 'dark'

// Проверка поддержки темной темы
function isDarkModeSupported(): boolean

// Применение темы к элементу
function applyTheme(element: HTMLElement, theme: 'light' | 'dark'): void

// Сохранение предпочтения
function saveThemePreference(theme: Theme): void

// Загрузка предпочтения
function loadThemePreference(): Theme | null

// Генерация CSS переменных для темы
function generateThemeVariables(theme: 'light' | 'dark'): string
```

5. `src/styles/components.css` - обновление всех компонентов:

```css
/* Использование CSS переменных во всех компонентах */

/* StoryViewer */
.storyViewer {
  background: var(--color-bg-primary);
  color: var(--color-text-primary);
}

/* Navigation */
.navButton {
  background: var(--color-button-bg);
  color: var(--color-button-text);
  border: 1px solid var(--color-border);
}

.navButton:hover {
  background: var(--color-button-bg-hover);
}

/* JumpModal */
.modal {
  background: var(--color-bg-primary);
  box-shadow: var(--shadow-lg);
}

.overlay {
  background: var(--color-bg-overlay);
}

/* LoadingScreen */
.loadingText {
  color: var(--color-text-secondary);
}

/* Scrollbar для темной темы */
@media (prefers-color-scheme: dark) {
  ::-webkit-scrollbar {
    background: var(--color-bg-secondary);
  }

  ::-webkit-scrollbar-thumb {
    background: var(--color-border);
  }
}
```

6. `tests/hooks/useTheme.test.ts`:

```typescript
describe('useTheme', () => {
  // Определение системной темы
  test('detects system theme preference')

  // Сохранение в localStorage
  test('persists theme choice')

  // Переключение тем
  test('toggles between themes')

  // Auto режим
  test('follows system theme in auto mode')

  // Применение к document
  test('applies theme to document element')

  // Реакция на изменения системы
  test('responds to system theme changes')
})
```

7. `tests/visual/themes.test.tsx`:

```typescript
// Визуальные тесты тем
describe('Theme Appearance', () => {
  test('light theme has correct colors')
  test('dark theme has correct colors')
  test('smooth transition between themes')
  test('all components respect theme')
})
```

ЦВЕТОВАЯ ПАЛИТРА:

Светлая тема:

- Фон: белый (#fff) и светло-серый (#f5f5f5)
- Текст: темно-серый (#333) и серый (#666)
- Акцент: синий (#4a90e2)

Темная тема:

- Фон: почти черный (#1a1a1a) и темно-серый (#2a2a2a)
- Текст: светло-серый (#e0e0e0) и серый (#b0b0b0)
- Акцент: голубой (#5a9fd4)

ТРЕБОВАНИЯ:

- Плавные переходы при смене темы (transition)
- Достаточный контраст для читаемости (WCAG AA)
- Консистентность цветов между компонентами
- Не слишком яркие цвета в темной теме
- Сохранение выбора пользователя

ПРОВЕРКА:

- Chrome DevTools → Rendering → Emulate CSS media feature
- Firefox → Inspector → Toggle print media simulation
- Lighthouse → Accessibility score > 95

Выведи полную реализацию системы тем.

````

---

## Промпт M4.5: Финальная полировка UI/UX

```text
Проведи финальную полировку всех UI/UX компонентов.

КОНТЕКСТ:
- Реализованы: форматирование текста, модальное окно, клавиатура, темы
- Нужно убедиться в консистентности и качестве
- Добавить финальные штрихи и микро-взаимодействия

ЗАДАЧА:
1. Проверь и улучши консистентность UI
2. Добавь микро-взаимодействия и feedback
3. Оптимизируй для мобильных устройств

ФАЙЛЫ ДЛЯ СОЗДАНИЯ/ОБНОВЛЕНИЯ:

1. `src/styles/global.css` - глобальные стили:
```css
/* Reset и нормализация */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Базовая типографика */
html {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
               'Helvetica Neue', Arial, sans-serif;
  font-size: 16px;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Фокус для доступности */
:focus-visible {
  outline: 2px solid var(--color-border-focus);
  outline-offset: 2px;
}

/* Убрать outline для мыши */
:focus:not(:focus-visible) {
  outline: none;
}

/* Анимации только если не отключены */
@media (prefers-reduced-motion: no-preference) {
  * {
    transition: color var(--transition-duration) ease,
                background-color var(--transition-duration) ease,
                border-color var(--transition-duration) ease;
  }
}

/* Отключение анимаций */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Мобильные оптимизации */
@media (max-width: 640px) {
  html {
    font-size: 17px; /* Крупнее для мобильных */
  }

  /* Увеличенные touch targets */
  button, a, [role="button"] {
    min-height: 44px;
    min-width: 44px;
  }
}

/* Landscape режим */
@media (orientation: landscape) and (max-height: 500px) {
  /* Компактный режим для landscape */
}
````

2. `src/components/TouchGestures.tsx`:

```typescript
// Компонент для обработки свайпов на мобильных

interface TouchGesturesProps {
  onSwipeLeft?: () => void
  onSwipeRight?: () => void
  onSwipeUp?: () => void
  onSwipeDown?: () => void
  threshold?: number // минимальная дистанция свайпа
  children: ComponentChildren
}

function TouchGestures(props: TouchGesturesProps) {
  // Touch события
  // Определение направления свайпа
  // Вызов соответствующего handler
}
```

3. `src/utils/deviceUtils.ts`:

```typescript
// Определение типа устройства и возможностей

function isTouchDevice(): boolean

function isIOS(): boolean

function isAndroid(): boolean

function getViewportSize(): { width: number; height: number }

function isLandscape(): boolean

function hasNotch(): boolean // для iPhone X+

function supportsVibration(): boolean

// Вибрация для feedback (опционально)
function vibrate(pattern?: number | number[]): void
```

4. `src/components/FeedbackToast.tsx`:

```typescript
// Компонент для показа кратких уведомлений

interface ToastProps {
  message: string
  type?: 'info' | 'success' | 'error'
  duration?: number
  position?: 'top' | 'bottom'
}

// Примеры использования:
// - "Скопировано в буфер"
// - "Нет соединения"
// - "История не найдена"
```

5. `src/styles/animations.css`:

```css
/* Минимальные анимации для feedback */

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    transform: translateY(10px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

/* Классы анимаций */
.animate-fadeIn {
  animation: fadeIn var(--transition-duration) ease;
}

.animate-slideUp {
  animation: slideUp var(--transition-duration) ease;
}

.animate-pulse {
  animation: pulse var(--transition-duration) ease;
}
```

6. `src/components/A11yAnnouncer.tsx`:

```typescript
// Компонент для объявлений screen reader

interface A11yAnnouncerProps {
  message: string
  politeness?: 'polite' | 'assertive'
}

// Использование:
// - Объявление смены истории
// - Объявление ошибок
// - Статус загрузки
```

7. `tests/a11y/accessibility.test.tsx`:

```typescript
// Тесты доступности
describe('Accessibility', () => {
  test('all interactive elements are keyboard accessible')
  test('proper ARIA labels and roles')
  test('color contrast meets WCAG AA')
  test('focus indicators are visible')
  test('screen reader announcements work')
})
```

8. `tests/mobile/mobileExperience.test.tsx`:

```typescript
// Тесты мобильного опыта
describe('Mobile Experience', () => {
  test('touch targets are large enough')
  test('swipe gestures work')
  test('landscape mode layout')
  test('virtual keyboard handling')
  test('viewport meta tag is correct')
})
```

ЧЕКЛИСТ ПОЛИРОВКИ:
□ Все кнопки имеют hover/active состояния
□ Фокус виден и логичен
□ Touch targets ≥ 44x44px
□ Свайпы работают на мобильных
□ Landscape режим выглядит хорошо
□ Темы консистентны везде
□ Анимации отключаются при prefers-reduced-motion
□ Screen reader объявления работают
□ Контраст соответствует WCAG AA
□ Шрифты читаемы на всех размерах экрана

META ТЕГИ для index.html:

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
<meta name="theme-color" content="#ffffff" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
```

ФИНАЛЬНАЯ ПРОВЕРКА:

1. Lighthouse score > 95 для всех категорий
2. Тест на реальных устройствах (iOS/Android)
3. Проверка в разных браузерах
4. Тест с screen reader (NVDA/JAWS/VoiceOver)
5. Тест на медленной сети (3G)

Выведи финальные улучшения и чеклист для QA.

```

---

## Метаданные для LLM

Фаза M4 завершает пользовательский интерфейс и опыт взаимодействия. Ключевые аспекты:

1. **Прогрессивное улучшение**: От базового функционала к продвинутым фичам
2. **Доступность**: Каждый компонент учитывает a11y требования
3. **Мобильный фокус**: Оптимизация для touch устройств
4. **Консистентность**: Единая система тем и стилей
5. **Отзывчивость**: Мгновенная реакция на действия пользователя

После выполнения всех промптов M4:
- UI полностью готов к production использованию
- Поддержка клавиатуры, touch жестов, screen readers
- Светлая и темная темы с автопереключением
- Модальное окно для быстрой навигации
- Оптимизация для всех размеров экранов
- Готовность к следующей фазе M5 (состояние и PWA)
```
